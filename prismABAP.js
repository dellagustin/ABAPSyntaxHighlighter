/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

 /* Original Prism.js was adapted by PragmatiQa(Ram Manohar Tiwari) to extend it for 
    ABAP syntax highlighting on 26/01/2014.
 */

(function(){

// Private helper vars
var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;

var _ = self.Prism = {
	util: {
		type: function (o) { 
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},
		
		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};
					
					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}
					
					return clone;
					
				case 'Array':
					return o.slice();
			}
			
			return o;
		}
	},
	
	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);
			
			for (var key in redef) {
				lang[key] = redef[key];
			}
			
			return lang;
		},
		
		// Insert a token before another token in a language literal
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];
			var ret = {};
				
			for (var token in grammar) {
			
				if (grammar.hasOwnProperty(token)) {
					
					if (token == before) {
					
						for (var newToken in insert) {
						
							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}
					
					ret[token] = grammar[token];
				}
			}
			
			return root[inside] = ret;
		},
		
		// Traverse a language definition with Depth First Search
		DFS: function(o, callback) {
			for (var i in o) {
				callback.call(o, i, o[i]);
				
				if (_.util.type(o) === 'Object') {
					_.languages.DFS(o[i], callback);
				}
			}
		}
	},

	highlightAll: function(async, callback) {
		var elements = document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code');

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, callback);
		}
	},
		
	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;
		
		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}
		
		if (parent) {
			language = (parent.className.match(lang) || [,''])[1];
			grammar = _.languages[language];
		}

		if (!grammar) {
			return;
		}
		
		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		
		// Set language on the parent, for styling
		parent = element.parentNode;
		
		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language; 
		}

		var code = element.textContent;
		
		if(!code) {
			return;
		}

		code = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};
		
		_.hooks.run('before-highlight', env);
		
		if (async && self.Worker) {
			var worker = new Worker(_.filename);	
			
			worker.onmessage = function(evt) {
				env.highlightedCode = Token.stringify(JSON.parse(evt.data), language);

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;
				
				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
			};
			
			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language)

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;
			
			callback && callback.call(element);
			
			_.hooks.run('after-highlight', env);
		}
	},
	
	highlight: function (text, grammar, language) {
		return Token.stringify(_.tokenize(text, grammar), language);
	},
	
	tokenize: function(text, grammar, language) {
		var Token = _.Token;
		
		var strarr = [text];
		
		var rest = grammar.rest;
		
		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}
			
			delete grammar.rest;
		}
								
		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}
			
			var pattern = grammar[token], 
				inside = pattern.inside,
				lookbehind = !!pattern.lookbehind,
				lookbehindLength = 0;
			
			pattern = pattern.pattern || pattern;
			
			for (var i=0; i<strarr.length; i++) { // Donâ€™t cache length as it changes during the loop
				
				var str = strarr[i];
				
				if (strarr.length > text.length) {
					// Something went terribly wrong, ABORT, ABORT!
					break tokenloop;
				}
				
				if (str instanceof Token) {
					continue;
				}
				
				pattern.lastIndex = 0;
				
				var match = pattern.exec(str);
				
				if (match) {
					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index - 1 + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    len = match.length,
					    to = from + len,
						before = str.slice(0, from + 1),
						after = str.slice(to + 1); 


					var args = [i, 1];
					
					if (before) {
						args.push(before);
					}
					

					var wrapped;

					/* Next line amended by PragmatiQa(Ram) */		
						
						if((token == 'keyword')&&((before.charAt(before.length-1) == '-')||(before.charAt(before.length-1) == '>')||(before.charAt(before.length-1) == '&'))){ 
												
							// wrapped = match;
							wrapped = new Token(' ', inside? _.tokenize(match, inside) : match);
						} else{	
							wrapped = new Token(token, inside? _.tokenize(match, inside) : match);		
						}

					// var wrapped = new Token(token, inside? _.tokenize(match, inside) : match);
					
					args.push(wrapped);
					
					if (after) {
						args.push(after);
					}
					
					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},
	
	hooks: {
		all: {},
		
		add: function (name, callback) {
			var hooks = _.hooks.all;
			
			hooks[name] = hooks[name] || [];
			
			hooks[name].push(callback);
		},
		
		run: function (name, env) {
			var callbacks = _.hooks.all[name];
			
			if (!callbacks || !callbacks.length) {
				return;
			}
			
			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content) {
	this.type = type;
	this.content = content;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (Object.prototype.toString.call(o) == '[object Array]') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}
	
	/* Next line added by PragmatiQa(Ram) */
	if(o.type == 'comment1'){ o.type = 'comment';}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};
	
	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}
	
	_.hooks.run('wrap', env);
	
	var attributes = '';
	
	for (var name in env.attributes) {
		attributes += name + '="' + (env.attributes[name] || '') + '"';
	}
	
	return '<' + env.tag + ' class="' + env.classes.join(' ') + '" ' + attributes + '>' + env.content + '</' + env.tag + '>';
	
};

if (!self.document) {
	// In worker
	self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code;
		
		self.postMessage(JSON.stringify(_.tokenize(code, _.languages[lang])));
		self.close();
	}, false);
	
	return;
}

// Get current script and highlight
var script = document.getElementsByTagName('script');

script = script[script.length - 1];

if (script) {
	_.filename = script.src;
	
	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		document.addEventListener('DOMContentLoaded', _.highlightAll);
	}
}

})();;
Prism.languages.abap= { 
    
	'comment': {
		pattern: /^[\*].*$/gm,  
		lookbehind: false
	},
    'string' : /(`|')(\\?.)*?\1/gm,	
 	'comment1': {
		pattern: /(\s\").*$/gm,  
		lookbehind: false
	},   
	'keyword' : /\b(TRANSFORMATION|SOURCE|RESULT|RETURNING|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|START-OF-SELECTION|MOVE-CORRESPONDING|END-OF-DEFINITION|ADD-CORRESPONDING|CUSTOMER-FUNCTION|SYSTEM-EXCEPTIONS|SELECTION-SCREEN|END-OF-SELECTION|SELECTION-SCREEN|LOAD-OF-PROGRAM|AUTHORITY-CHECK|LIST-PROCESSING|RIGHT-JUSTIFIED|SCROLL-BOUNDARY|SELECTION-TABLE|INTERFACE-POOL|ENDENHANCEMENT|IMPLEMENTATION|SELECT-OPTIONS|INITIALIZATION|LINE-SELECTION|LINE-SELECTION|LEFT-JUSTIFIED|FUNCTION-POOL|CLASS-METHODS|FIELD-SYMBOLS|COMMUNICATION|PRINT-CONTROL|VALUE-REQUEST|CLASS-EVENTS|ENDINTERFACE|FIELD-GROUPS|USER-COMMAND|COL_NEGATIVE|HELP-REQUEST|NO-SCROLLING|REDEFINITION|SYNTAX-CHECK|SYNTAX-TRACE|TRANSPORTING|ENHANCEMENT|END-OF-PAGE|TOP-OF-PAGE|ENDFUNCTION|TRANSACTION|BREAK-POINT|CONCATENATE|EDITOR-CALL|INTENSIFIED|OCCURRENCES|RADIOBUTTON|SYSTEM-CALL|CLASS-POOL|CLASS-DATA|DEFINITION|INTERFACES|PARAMETERS|TYPE-POOLS|ENDPROVIDE|COL_NORMAL|DESCENDING|DUPLICATES|EXCEPTIONS|INHERITING|LINE-COUNT|MESSAGE-ID|NO-HEADING|NON-UNIQUE|WITH-TITLE|TYPE-POOL|CONSTANTS|INTERFACE|PROTECTED|ENDMETHOD|ENDMODULE|ENDSELECT|REQUESTED|APPENDING|ASCENDING|ASSIGNING|COMPARING|COMPONENT|EXCLUDING|EXPORTING|IMPORTING|INFOTYPES|LINE-SIZE|MATCHCODE|NUMOFCHAR|PARAMETER|PF-STATUS|REFERENCE|SEPARATED|SPECIFIED|STRUCTURE|TRANSLATE|CONTEXTS|ENDCLASS|ASSIGNED|CONTINUE|ENDWHILE|FUNCTION|SUPPLIED|ADJACENT|ANALYZER|CENTERED|CHANGING|CHECKBOX|CONDENSE|CONTROLS|CURRENCY|DATABASE|DBMAXLEN|DECIMALS|DESCRIBE|DISTINCT|ENCODING|EXPONENT|EXTENDED|GENERATE|ITERATOR|LANGUAGE|MULTIPLY|NEW-LINE|NEW-PAGE|NO-TITLE|OPTIONAL|POSITION|PROPERTY|ROLLBACK|SELECTOR|STANDARD|STARTING|SUBTRACT|SUPPRESS|TEXTPOOL|TITLEBAR|TRANSFER|INCLUDE|PROGRAM|METHODS|PRIVATE|SECTION|STATICS|BETWEEN|BINDING|BYTE-CA|BYTE-CN|BYTE-CO|BYTE-CS|BYTE-NA|BYTE-NS|CLEANUP|ENDCASE|ENDEXEC|ENDFORM|ENDLOOP|INITIAL|PERFORM|PROVIDE|ALIASES|BIT-AND|BIT-NOT|BIT-XOR|CHARLEN|COLLECT|COMMENT|COMPUTE|CONTROL|CONVERT|COUNTRY|DATASET|DEFAULT|EXTRACT|GREATER|HANDLER|HELP-ID|HOTSPOT|INVERSE|LEADING|MESSAGE|NO-SIGN|NO-ZERO|OVERLAY|RAISING|RECEIVE|REFRESH|REPLACE|RESERVE|SUMMARY|XSTRLEN|REPORT|EVENTS|PUBLIC|RANGES|STATIC|DURING|CHANGE|DEFINE|ELSEIF|ENDFOR|ENDTRY|METHOD|MODULE|RETURN|SCREEN|SELECT|APPEND|ASSIGN|ASSERT|BINARY|BIT-OR|BUFFER|CLIENT|COMMIT|CREATE|CURSOR|DELETE|DEMAND|DETAIL|DIALOG|DIVIDE|DYNPRO|EXPORT|FIELDS|FORMAT|HASHED|HEADER|IMPORT|INSERT|LOCALE|MARGIN|MEMORY|MODIFY|NO-GAP|NUMBER|OCCURS|OTHERS|OUTPUT|PLACES|REJECT|SCROLL|SEARCH|SHARED|SINGLE|SORTED|STRLEN|SUBMIT|SUPPLY|SYMBOL|TABLES|UNIQUE|UNPACK|UPDATE|WINDOW|BOUND|CLASS|LOCAL|SPOTS|TYPES|BEGIN|BLOCK|CATCH|CHECK|ENDAT|ENDDO|ENDIF|ENDON|FIRST|LEAVE|WHILE|BLANK|BOUND|CLEAR|CLOSE|COLOR|COUNT|EQUAL|EVENT|FETCH|FIELD|FLOOR|FRAME|GROUP|INDEX|INPUT|LINES|LOWER|LOG10|NODES|ORDER|PRINT|RAISE|RESET|ROUND|SHIFT|SPLIT|STAMP|TABLE|TIMES|TITLE|TRUNC|ULINE|UNDER|UPPER|USING|VALUE|WHERE|WRITE|DATA|CALL|CASE|EACH|ELSE|EXEC|EXIT|FORM|LAST|LOOP|STOP|WHEN|ACOS|ASIN|ATAN|BACK|BADI|CASE|CEIL|CODE|COPY|COSH|DATE|EDIT|FIND|FRAC|FREE|FROM|HIDE|ICON|INTO|JOIN|LEFT|LESS|LIKE|LINE|LOAD|MASK|MESH|MODE|MOVE|NEXT|OPEN|PACK|PAGE|READ|ROWS|RTTI|SCAN|SIGN|SINH|SIZE|SKIP|SORT|SQRT|TANH|TASK|TEXT|TIME|TYPE|UNIT|WAIT|WITH|WORK|ZONE|AND|END|NEW|NOT|SQL|TRY|ABS|ABS|ABS|ADD|ALL|ANY|AVG|BIT|CNT|COS|DIV|EXP|FOR|GET|KEY|LOG|MAX|MIN|MOD|PUT|REF|RUN|SET|SIN|SUM|TAN|XOR|AT|CA|CN|CO|CP|CS|DO|EQ|GE| GT|IF|IN|IS|LE| LT|NA|NE|NP|NS|OF|ON|OR|AS|BY|ID|NO|TO|UP|M|O|Z|C|I|X)\b/gi,
	// 'boolean' : /\b(TRUE|FALSE|NULL)\b/gi,

	'number' : /\b-?(0x)?\d*\.?[\da-f]+\b/g,
	// 'operator' : /\b(<|:|,|\(|\)|.|=|=\?)\b/gi,
	// 'ignore' : /&(lt|gt|amp);/gi,
	// 'punctuation' : /[,.:]/g
};
;

(function(){

if(!window.Prism) {
	return;
}

function $$(expr, con) {
	return Array.prototype.slice.call((con || document).querySelectorAll(expr));
}

function hasClass(element, className) {
  className = " " + className + " ";
  return (" " + element.className + " ").replace(/[\n\t]/g, " ").indexOf(className) > -1
}

var CRLF = crlf = /\r?\n|\r/g;
    
function highlightLines(pre, lines, classes) {
	var ranges = lines.replace(/\s+/g, '').split(','),
	    offset = +pre.getAttribute('data-line-offset') || 0;
	
	var lineHeight = parseFloat(getComputedStyle(pre).lineHeight);

	for (var i=0, range; range = ranges[i++];) {
		range = range.split('-');
					
		var start = +range[0],
		    end = +range[1] || start;
		
		var line = document.createElement('div');
		
		line.textContent = Array(end - start + 2).join(' \r\n');
		line.className = (classes || '') + ' line-highlight';

    //if the line-numbers plugin is enabled, then there is no reason for this plugin to display the line numbers
    if(!hasClass(pre, 'line-numbers')) {
      line.setAttribute('data-start', start);

      if(end > start) {
        line.setAttribute('data-end', end);
      }
    }

		line.style.top = (start - offset - 1) * lineHeight + 'px';

    //allow this to play nicely with the line-numbers plugin
    if(hasClass(pre, 'line-numbers')) {
      //need to attack to pre as when line-numbers is enabled, the code tag is relatively which screws up the positioning
      pre.appendChild(line);
    } else {
      (pre.querySelector('code') || pre).appendChild(line);
    }
	}
}

function applyHash() {
	var hash = location.hash.slice(1);
	
	// Remove pre-existing temporary lines
	$$('.temporary.line-highlight').forEach(function (line) {
		line.parentNode.removeChild(line);
	});
	
	var range = (hash.match(/\.([\d,-]+)$/) || [,''])[1];
	
	if (!range || document.getElementById(hash)) {
		return;
	}
	
	var id = hash.slice(0, hash.lastIndexOf('.')),
	    pre = document.getElementById(id);
	    
	if (!pre) {
		return;
	}
	
	if (!pre.hasAttribute('data-line')) {
		pre.setAttribute('data-line', '');
	}

	highlightLines(pre, range, 'temporary ');

	document.querySelector('.temporary.line-highlight').scrollIntoView();
}

var fakeTimer = 0; // Hack to limit the number of times applyHash() runs

Prism.hooks.add('after-highlight', function(env) {
	var pre = env.element.parentNode;
	var lines = pre && pre.getAttribute('data-line');
	
	if (!pre || !lines || !/pre/i.test(pre.nodeName)) {
		return;
	}
	
	clearTimeout(fakeTimer);
	
	$$('.line-highlight', pre).forEach(function (line) {
		line.parentNode.removeChild(line);
	});
	
	highlightLines(pre, lines);
	
	fakeTimer = setTimeout(applyHash, 1);
});

addEventListener('hashchange', applyHash);

})();
;
Prism.hooks.add('after-highlight', function (env) {
	// works only for <code> wrapped inside <pre data-line-numbers> (not inline)
	var pre = env.element.parentNode;
	if (!pre || !/pre/i.test(pre.nodeName) || pre.className.indexOf('line-numbers') === -1) {
		return;
	}

	var linesNum = (1 + env.code.split('\n').length);
	var lineNumbersWrapper;

	lines = new Array(linesNum);
	lines = lines.join('<span></span>');

	lineNumbersWrapper = document.createElement('span');
	lineNumbersWrapper.className = 'line-numbers-rows';
	lineNumbersWrapper.innerHTML = lines;

	if (pre.hasAttribute('data-start')) {
		pre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);
	}

	env.element.appendChild(lineNumbersWrapper);

});;
(function(){

if (!self.Prism) {
	return;
}

var url = /\b([a-z]{3,7}:\/\/|tel:)[\w-+%~/.:]+/,
    email = /\b\S+@[\w.]+[a-z]{2}/,
    linkMd = /\[([^\]]+)]\(([^)]+)\)/,
    
	// Tokens that may contain URLs and emails
    candidates = ['comment', 'url', 'attr-value', 'string'];

for (var language in Prism.languages) {
	var tokens = Prism.languages[language];
	
	Prism.languages.DFS(tokens, function (type, def) {
		if (candidates.indexOf(type) > -1) {
			if (!def.pattern) {
				def = this[type] = {
					pattern: def
				};
			}
			
			def.inside = def.inside || {};
			
			if (type == 'comment') {
				def.inside['md-link'] = linkMd;
			}
			
			def.inside['url-link'] = url;
			def.inside['email-link'] = email;
		}
	});
	
	tokens['url-link'] = url;
	tokens['email-link'] = email;
}

Prism.hooks.add('wrap', function(env) {
	if (/-link$/.test(env.type)) {
		env.tag = 'a';
		
		var href = env.content;
		
		if (env.type == 'email-link') {
			href = 'mailto:' + href;
		}
		else if (env.type == 'md-link') {
			// Markdown
			var match = env.content.match(linkMd);
			
			href = match[2];
			env.content = match[1];
		}
		
		env.attributes.href = href;
	}
});

})();
;
(function(){

if (!self.Prism) {
	return;
}

if (Prism.languages.css) {
	Prism.languages.css.atrule.inside['atrule-id'] = /^@[\w-]+/;
	
	Prism.languages.css.selector = {
		pattern: Prism.languages.css.selector,
		inside: {
			'pseudo-class': /:[\w-]+/,
			'pseudo-element': /::[\w-]+/
		}
	};
}

if (Prism.languages.markup) {
	Prism.languages.markup.tag.inside.tag.inside['tag-id'] = /[\w-]+/;
	
	var Tags = {
		HTML: {
			'a': 1, 'abbr': 1, 'acronym': 1, 'b': 1, 'basefont': 1, 'bdo': 1, 'big': 1, 'blink': 1, 'cite': 1, 'code': 1, 'dfn': 1, 'em': 1, 'kbd': 1,  'i': 1, 
			'rp': 1, 'rt': 1, 'ruby': 1, 's': 1, 'samp': 1, 'small': 1, 'spacer': 1, 'strike': 1, 'strong': 1, 'sub': 1, 'sup': 1, 'time': 1, 'tt': 1,  'u': 1, 
			'var': 1, 'wbr': 1, 'noframes': 1, 'summary': 1, 'command': 1, 'dt': 1, 'dd': 1, 'figure': 1, 'figcaption': 1, 'center': 1, 'section': 1, 'nav': 1,
			'article': 1, 'aside': 1, 'hgroup': 1, 'header': 1, 'footer': 1, 'address': 1, 'noscript': 1, 'isIndex': 1, 'main': 1, 'mark': 1, 'marquee': 1,
			'meter': 1, 'menu': 1
		},
		SVG: {
			'animateColor': 1, 'animateMotion': 1, 'animateTransform': 1, 'glyph': 1, 'feBlend': 1, 'feColorMatrix': 1, 'feComponentTransfer': 1, 
			'feFuncR': 1, 'feFuncG': 1, 'feFuncB': 1, 'feFuncA': 1, 'feComposite': 1, 'feConvolveMatrix': 1, 'feDiffuseLighting': 1, 'feDisplacementMap': 1, 
			'feFlood': 1, 'feGaussianBlur': 1, 'feImage': 1, 'feMerge': 1, 'feMergeNode': 1, 'feMorphology': 1, 'feOffset': 1, 'feSpecularLighting': 1, 
			'feTile': 1, 'feTurbulence': 1, 'feDistantLight': 1, 'fePointLight': 1, 'feSpotLight': 1, 'linearGradient': 1, 'radialGradient': 1, 'altGlyph': 1, 
			'textPath': 1, 'tref': 1, 'altglyph': 1, 'textpath': 1, 'tref': 1, 'altglyphdef': 1, 'altglyphitem': 1, 'clipPath': 1, 'color-profile': 1, 'cursor': 1, 
			'font-face': 1, 'font-face-format': 1, 'font-face-name': 1, 'font-face-src': 1, 'font-face-uri': 1, 'foreignObject': 1, 'glyph': 1, 'glyphRef': 1, 
			'hkern': 1, 'vkern': 1, 
		},
		MathML: {}
	}
}

var language;

Prism.hooks.add('wrap', function(env) {
	if ((['tag-id'].indexOf(env.type) > -1
		|| (env.type == 'property' && env.content.indexOf('-') != 0)
		|| (env.type == 'atrule-id'&& env.content.indexOf('@-') != 0)
		|| (env.type == 'pseudo-class'&& env.content.indexOf(':-') != 0) 
		|| (env.type == 'pseudo-element'&& env.content.indexOf('::-') != 0) 
	    || (env.type == 'attr-name' && env.content.indexOf('data-') != 0)
	    ) && env.content.indexOf('<') === -1
	) {
		var searchURL = 'w/index.php?fulltext&search=';
		
		env.tag = 'a';
		
		var href = 'http://docs.webplatform.org/';
		
		if (env.language == 'css') {
			href += 'wiki/css/'
			
			if (env.type == 'property') {
				href += 'properties/';
			}
			else if (env.type == 'atrule-id') {
				href += 'atrules/';
			}
			else if (env.type == 'pseudo-class') {
				href += 'selectors/pseudo-classes/';
			}
			else if (env.type == 'pseudo-element') {
				href += 'selectors/pseudo-elements/';
			}
		}
		else if (env.language == 'markup') {
			if (env.type == 'tag-id') {
				// Check language
				language = getLanguage(env.content) || language;
				
				if (language) {
					href += 'wiki/' + language + '/elements/';
				}
				else {
					href += searchURL;
				}
			}
			else if (env.type == 'attr-name') {
				if (language) {
					href += 'wiki/' + language + '/attributes/';
				}
				else {
					href += searchURL;
				}
			}
		}
		
		href += env.content;
		
		env.attributes.href = href;
		env.attributes.target = '_blank';
	}
});

function getLanguage(tag) {
	var tagL = tag.toLowerCase();
	
	if (Tags.HTML[tagL]) {
		return 'html';
	}
	else if (Tags.SVG[tag]) {
		return 'svg';
	}
	else if (Tags.MathML[tag]) {
		return 'mathml';
	}
	
	// Not in dictionary, perform check
	if (Tags.HTML[tagL] !== 0) {
		var htmlInterface = (document.createElement(tag).toString().match(/\[object HTML(.+)Element\]/) || [])[1];
		
		if (htmlInterface && htmlInterface != 'Unknown') {
			Tags.HTML[tagL] = 1;
			return 'html';
		}
	}
	
	Tags.HTML[tagL] = 0;
	
	if (Tags.SVG[tag] !== 0) {
		var svgInterface = (document.createElementNS('http://www.w3.org/2000/svg', tag).toString().match(/\[object SVG(.+)Element\]/) || [])[1];
		
		if (svgInterface && svgInterface != 'Unknown') {
			Tags.SVG[tag] = 1;
			return 'svg';
		}
	}
	
	Tags.SVG[tag] = 0;
	
	// Lame way to detect MathML, but browsers donâ€™t expose interface names there :(
	if (Tags.MathML[tag] !== 0) {
		if (tag.indexOf('m') === 0) {
			Tags.MathML[tag] = 1;
			return 'mathml';
		}
	}
	
	Tags.MathML[tag] = 0;
	
	return null;
}

})();;
(function(){

if (!self.Prism || !self.document || !document.querySelector) {
	return;
}

var Extensions = {
	'js': 'javascript',
	'html': 'markup',
	'svg': 'markup'
};

Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function(pre) {
	var src = pre.getAttribute('data-src');
	var extension = (src.match(/\.(\w+)$/) || [,''])[1];
	var language = Extensions[extension] || extension;
	
	var code = document.createElement('code');
	code.className = 'language-' + language;
	
	pre.textContent = '';
	
	code.textContent = 'Loadingâ€¦';
	
	pre.appendChild(code);
	
	var xhr = new XMLHttpRequest();
	
	xhr.open('GET', src, true);

	xhr.onreadystatechange = function() {
		if (xhr.readyState == 4) {
			
			if (xhr.status < 400 && xhr.responseText) {
				code.textContent = xhr.responseText;
			
				Prism.highlightElement(code);
			}
			else if (xhr.status >= 400) {
				code.textContent = 'âœ– Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
			}
			else {
				code.textContent = 'âœ– Error: File does not exist or is empty';
			}
		}
	};
	
	xhr.send(null);
});

})();;
