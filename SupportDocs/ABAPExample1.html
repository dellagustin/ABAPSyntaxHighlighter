<!DOCTYPE html>
<html>
<head>
<link href="prismABAP.css" rel="stylesheet" />
<script src="prismABAP.js"></script>

</head>
<body>
<pre class="line-numbers language-abap"><code>*&---------------------------------------------------------------------*
*& Report  RODPS_REPL_TEST
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

report  rodps_repl_test line-size 1023.

tables sscrfields.

data:
  gs_dyntxt     type smp_dyntxt.                            "#EC NEEDED
data : begin of lv_select,
        select,
       end of lv_select.
  lv_select-select = 'abc'.
parameters: i_ds     type odq_queuename,
            i_mode   type rodps_repl_mode default cl_rodps_replication=>c_mode-full.
selection-screen begin of block sel with frame title text-001.
parameters: i_fnam   type fieldname,
            i_opt    type rsoption,
            i_low    type rslow,
            i_high   type rshigh.
selection-screen end of block sel.
data: g_field type fieldname.
select-options: it_proj for g_field no intervals.
parameters: i_point  type rodps_repl_pointer.
parameters: i_noalv as checkbox.
parameters: i_maxrec type i default 1000.

selection-screen function key 1.

data: gr_replication    type ref to cl_rodps_replication,
      l_subscriber_type type odq_subscriber_type value cl_rodps_repl_subscriber=>c_subscriber_type-bobj_ds,
      l_subscriber_name type odq_subscriber_id   value 'TestRepository_DoesNotExist',
      l_subscriber_proc type rodps_repl_process  value 'TestDataFlow_DoesNotExist',
      l_pointer         type rodps_repl_pointer,
      lt_return         type bapirettab,
      ls_return         type bapiret2,
      lt_data           type rodps_repl_t_xdata,
      ls_data           type rodps_repl_s_xdata.
data: gt_select   type rodps_repl_t_selection,
      gs_select   type rodps_repl_s_selection,
      gt_project  type rodps_repl_t_projection,
      gs_project  type rodps_repl_s_projection.


initialization.

  gs_dyntxt-icon_id     = icon_delete.
  gs_dyntxt-icon_text   = 'Reset Delta'(002).
  sscrfields-functxt_01 = gs_dyntxt.


at selection-screen.

  case sscrfields-ucomm.
    when 'FC01'.
      perform reset_delta.
  endcase.


start-of-selection.

  if i_point is initial.
    if not i_fnam is initial.
      gs_select-fieldname = i_fnam.
      gs_select-opt       = i_opt.
      gs_select-sign      = 'I'.
      gs_select-low       = i_low.
      gs_select-high      = i_high.
      append gs_select to gt_select.
    endif.
    loop at it_proj.
      gs_project-fieldname = it_proj-low.
      append gs_project to gt_project.
    endloop.
    call function 'RODPS_REPL_SOURCE_OPEN'
      exporting
        i_subscriber_type    = l_subscriber_type
        i_subscriber_name    = l_subscriber_name
        i_subscriber_process = l_subscriber_proc
        i_queuename          = i_ds
        i_extraction_mode    = i_mode
      importing
        e_pointer            = l_pointer
      tables
        it_select            = gt_select
        it_projection        = gt_project
        et_return            = lt_return.
    loop at lt_return into ls_return.
      write: / ls_return-message.
      return.
    endloop.
  else.
    l_pointer = i_point.
  endif.



  data: lr_conv        type ref to cl_abap_conv_in_ce.
  data: lr_structdescr type ref to cl_abap_structdescr,
        lr_cdata       type ref to data.
  field-symbols: &lt;ls_cdata>     type any.
  data: lt_fields      type rodps_repl_t_field,
        ls_fields      type rodps_repl_s_field,
        lt_component   type cl_abap_structdescr=>component_table,
        ls_component   type line of cl_abap_structdescr=>component_table,
        l_length       type i,
        l_linno        type i,
        l_rawstring    type xstring,
        l_string       type string,
        l_no_more_data type odq_boolean.
  call function 'RODPS_REPL_SOURCE_GET_DETAIL'
    exporting
      i_subscriber_type = l_subscriber_type
      i_queuename       = i_ds
    tables
      et_fields         = lt_fields.
  loop at lt_fields into ls_fields.
    if not gt_project is initial.
      read table gt_project with key fieldname = ls_fields-name transporting no fields.
      if sy-subrc &lt;> 0. continue. endif.
    endif.
    ls_component-name = ls_fields-name.
    l_length = ls_fields-outputleng.
    ls_component-type = cl_abap_elemdescr=>get_c( p_length = l_length ).
    append ls_component to lt_component.
  endloop.
  lr_structdescr = cl_abap_structdescr=>get( p_components = lt_component
                                             p_strict     = abap_false ).
  create data lr_cdata type handle lr_structdescr.
  assign lr_cdata->* to <ls_cdata>.
  lr_conv = cl_abap_conv_in_ce=>create( ).

  data:
    l_colindex     type i,
    l_cutoff       type c length 1,
    l_rowwidth     type i,
    lt_colwidths   type standard table of i with default key.

  field-symbols:
    <l_colwidth>   like line of lt_colwidths,
    <ls_component> like line of lr_structdescr->components,
    <l_data>       type any,
    <lt_data>      type standard table.

  if i_noalv is initial.

    data:
      lr_data             type ref to data,
      lr_model            type ref to if_odq_queue_model_ext,
      lr_tabledescr       type ref to cl_abap_tabledescr,
      l_with_delta_append type abap_bool.


    case i_mode.
      when cl_rodps_replication=>c_mode-delta    or
           cl_rodps_replication=>c_mode-recovery.
        l_with_delta_append = 'X'.
      when others.
        clear l_with_delta_append.
    endcase.

    lr_model       = cl_odq_facade=>get_queue_model( cl_rodps_datasource_model=>c_modelname ).
    lr_structdescr = lr_model->get_structdescr(
                       i_queuename         = i_ds
                       i_with_delta_append = l_with_delta_append
                     ).
    lr_tabledescr  = cl_abap_tabledescr=>get( lr_structdescr ).

    create data lr_data type handle lr_tabledescr.
    assign lr_data->* to <lt_data>.

  else.

    l_rowwidth = 1.
    do.
      l_colindex = sy-index.
      assign component l_colindex of structure <ls_cdata> to <l_data>.
      if sy-subrc eq 0.
        read table lr_structdescr->components assigning <ls_component> index l_colindex.
        assert sy-subrc eq 0.
        describe field <l_data> output-length l_length.
*       Calculate maximum of output length and string length of column header (field name)
        if l_length lt strlen( <ls_component>-name ).
          l_length = strlen( <ls_component>-name ).
        endif.
*       Add column width to current row width including column separator
        l_rowwidth = l_rowwidth + l_length + 1.
        if l_rowwidth le sy-linsz.
          append initial line to lt_colwidths assigning <l_colwidth>.
          <l_colwidth> = l_length.
        else.
*         Output length of record exceeds line size.
          l_cutoff = 'X'.
          l_rowwidth = l_rowwidth - l_length - 1.
          l_length = sy-linsz - l_rowwidth.
          if l_length lt 3.
            subtract 1 from l_colindex.
            if l_colindex gt 0.
              read table lt_colwidths assigning <l_colwidth> index l_colindex.
              l_rowwidth = l_rowwidth - <l_colwidth> - 1.
              delete lt_colwidths index l_colindex.
            endif.
          endif.
          add 3 to l_rowwidth.
          exit. "Do
        endif.
      else.
        exit. "Do
      endif.
    enddo.

    uline at /(l_rowwidth).
    write / sy-vline no-gap.
    loop at lt_colwidths assigning <l_colwidth>.
      read table lr_structdescr->components assigning <ls_component> index sy-tabix.
      write: at (<l_colwidth>) <ls_component>-name color col_heading no-gap, sy-vline no-gap.
    endloop.
    if not l_cutoff is initial.
      write '...' color col_heading no-gap.
    endif.
    uline at /(l_rowwidth).

  endif.

  data l_recno type i.

  l_recno = 0.
  while l_no_more_data is initial.
    refresh lt_data.
    call function 'RODPS_REPL_SOURCE_FETCH'
      exporting
        i_pointer      = l_pointer
      importing
        e_no_more_data = l_no_more_data
      tables
        et_data        = lt_data
        et_return      = lt_return.
    loop at lt_return into ls_return.
      write: / ls_return-message.
      return.
    endloop.

    loop at lt_data into ls_data.
      concatenate l_rawstring ls_data-data into l_rawstring in byte mode.
      if ls_data-continuation = space.
        lr_conv->reset( exporting input = l_rawstring ).
        lr_conv->read( importing data = l_string ).
        <ls_cdata> = l_string.
        if i_maxrec eq 0        or
           l_recno  lt i_maxrec.
          add 1 to l_recno.
          if i_noalv is initial.
            field-symbols <ls_data> type any.
            append initial line to <lt_data> assigning <ls_data>.
            move-corresponding <ls_cdata> to <ls_data>.
          else.
*           now the data could be moved-corresponding to the typed structure
            write / sy-vline no-gap.
            loop at lt_colwidths assigning <l_colwidth>.
              assign component sy-tabix of structure <ls_cdata> to <l_data>.
              write: at (<l_colwidth>) <l_data> color col_normal intensified off no-gap, sy-vline no-gap.
            endloop.
            if not l_cutoff is initial.
              write '...' color col_normal intensified off no-gap.
            endif.
          endif.
        elseif l_recno eq i_maxrec.
          if not sy-batch is initial.
            if l_cutoff is initial.
              l_length = l_rowwidth - 2.
              write: / sy-vline no-gap, at (l_length) '...' centered color col_normal intensified off no-gap, sy-vline no-gap.
            else.
              l_length = l_rowwidth - 1.
              write: / sy-vline no-gap, at (l_length) '...' centered color col_normal intensified off no-gap.
            endif.
            add 1 to l_recno.
          endif.
        endif.
        clear l_rawstring.
      endif.
    endloop.
  endwhile.

  if i_noalv is initial.

    data:
      lr_alv           type ref to cl_salv_table,
      lr_alv_columns   type ref to cl_salv_columns_table,
      lt_alv_columns   type salv_t_column_ref,
      lr_alv_functions type ref to cl_salv_functions_list,
      l_short_text     type scrtext_s,
      l_medium_text    type scrtext_m,
      l_long_text      type scrtext_l,
      l_tooltip        type lvc_tip.

    field-symbols:
      <ls_alv_column>  like line of lt_alv_columns.


    cl_salv_table=>factory(
      exporting
        list_display = sy-batch
      importing
        r_salv_table = lr_alv
      changing
        t_table      = <lt_data>
    ).

*   Set default functions
    lr_alv_functions = lr_alv->get_functions( ).
    lr_alv_functions->set_all( 'X' ).
*   Set column headings to technical field names
    lr_alv_columns   = lr_alv->get_columns( ).
    lt_alv_columns   = lr_alv_columns->get( ).
    loop at lt_alv_columns assigning <ls_alv_column>.
      l_tooltip = <ls_alv_column>-r_column->get_long_text( ).
      l_short_text = l_medium_text = l_long_text = <ls_alv_column>-r_column->get_columnname( ).
      if l_short_text ne l_long_text.
        clear l_short_text.
      endif.
      if l_medium_text ne l_medium_text.
        clear l_medium_text.
      endif.
      if l_tooltip is initial.
        l_tooltip = l_long_text.
      endif.
      <ls_alv_column>-r_column->set_short_text( l_short_text ).
      <ls_alv_column>-r_column->set_medium_text( l_medium_text ).
      <ls_alv_column>-r_column->set_long_text( l_long_text ).
      <ls_alv_column>-r_column->set_tooltip( l_tooltip ).
    endloop.
*   Display table
    lr_alv->display( ).

  else.

    uline at /(l_rowwidth).

  endif.

*&---------------------------------------------------------------------*
*&      Form  reset_delta
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
form reset_delta.

  data:
    l_answer type c length 1.

  check not i_ds is initial.

  call function 'POPUP_TO_CONFIRM'
    exporting
*     TITLEBAR                    = ' '
*     DIAGNOSE_OBJECT             = ' '
      text_question               = 'Delta-Abonnement wirklich zurÃ¼cksetzen?'(003)
*     TEXT_BUTTON_1               = 'Ja'(001)
*     ICON_BUTTON_1               = ' '
*     TEXT_BUTTON_2               = 'Nein'(002)
*     ICON_BUTTON_2               = ' '
*     DEFAULT_BUTTON              = '1'
*     DISPLAY_CANCEL_BUTTON       = 'X'
*     USERDEFINED_F1_HELP         = ' '
*     START_COLUMN                = 25
*     START_ROW                   = 6
*     POPUP_TYPE                  =
*     IV_QUICKINFO_BUTTON_1       = ' '
*     IV_QUICKINFO_BUTTON_2       = ' '
    importing
      answer                      = l_answer
*   TABLES
*     PARAMETER                   =
    exceptions
      text_not_found              = 1
      others                      = 2.
  if sy-subrc eq 0 and l_answer = '1'.
    call function 'RODPS_REPL_SOURCE_RESET'
      exporting
        i_subscriber_type    = l_subscriber_type
        i_subscriber_name    = l_subscriber_name
        i_subscriber_process = l_subscriber_proc
        i_queuename          = i_ds
      tables
        et_return            = lt_return.
  endif.

endform.                    "reset_delta
</code>
</pre>
<!--script src="prism-sql.min.js"></script-->

</body>
</html>